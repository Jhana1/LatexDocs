%!TEX root = ./main.tex
%----------------------------------------------------------------------------------------
% CLANG INTEGRATION
%----------------------------------------------------------------------------------------

\section{Clang Integration} % Major section
CAPA utilises the Clang Libtooling library in order to perform semantic static analysis of any C
codebase, via a hook into the clang frontend action. Clang is used for a number of reasons, it is
one of the largest C family compilers in use today, it is standards compliant and up to date. The
Clang development team also aim to provide Clang as a first class library for tool and plugin
development. The constant development and improvement of the Clang project allows CAPA to focus
primarily on the analysis of source code, rather than the structure and scaffolding around parsing
and generating static information about C source files.

\subsection{Clang Compilation}
Clang is the C frontend of the llvm project, and as such it compiles source code into llvm
intermediate representation, rather than directly to ASM. This allows Clang to target a common
language leveraging the llvm compiler to perform the final compilation to a native binary. A core
tenant of the Clang toolset is that Clang is more than just a Compiler, it also a library, which
allows for third party individuals to use and extend the Clang framework in a variety of ways.
\cite{clangFeatures}
The Clang frontend compilation phase is a 4 step process, where Source code is lexed to tokens,
parsed into an AST for programatic manipulation. Semantic Analysis is performed on the AST to
identify standards compliance and enforce some optimisations, before being process by the Code
Generator which exports LLVM IR. Each of these phases in the frontend action is exposed via a public
library which can be utilised by third party tools.

\subsection{Benefits of Clang}
Clang provides a number of benefits over rolling your own source code analyser. Primarily Clang is
one of the most used C language compilers in the world, it is well maintained, well documented,
standards compliant and provides first class library support at most levels of compilation. Using
existing tooling for the heavy lifting of the project allowed for far more time to be invested in
further developing the project, rather than scaffolding the basic fundamentals. Using the Clang
libraries also allows for expansion in the future to parsing more than just C files, there is
potential to parse any file compilable by Clang, from C++, Obj-C and from Clang4.0 onwards Cuda-C
\cite{clangFeatures}.

\subsection{Integrating CAPA}\label{integrating_capa}
The Clang compiler exposes a public library for interfacing with their intermediate
compilation stage representations of the original source. For the purpose of this project it was
decided to use the exposed AST interface in order to perform the static analysis. Clang provides a
number of methods for working with the AST, namely the Visitor and Matcher interfaces. The Visitor
library utilises the visitor pattern, and a callback is undertaken upon visiting any node which
meets the requirements set forth in the visitor module. This is a useful tool, however it is not as
powerful as the Matcher interface, which allows complex grammars to be generated for highly
specific, tailored matches. CAPA utilises the ASTMatcher callback interface in order to provide complex
generic and extensible traversals of the AST. 

\includegraphicscaption{./Pictures/ClangHook.png}{CAPA Hook-In}

As CAPA is a fork of OCLint\cite{oclint} the scaffolding around the Clang integration was already
provided. CAPA accepts compile flags via the command line which are passed through to the existing
Clang compilation libraries which engage in the frontend action. Clang processes the source files
both lexing and parsing before constructing the Abstract Syntax Tree. CAPA hooks into Clang after
this compilation phase and provides requests after the parser has constructed the AST. These
requests are of the form of AST Matcher descriptors which descripe a topology of the AST. Clang then
traverses the generated AST searching for regions of the tree that meet the requirements set forth
within the matcher grammar. Upon detection of a region, the Clang compiler returns the matching
parent node, as well as any additionally bound nodes back to CAPA through a specified callback. This
callback is also provided the AST Context, an object defined by Clang which contains relevant
additional information about the AST, such as source information and optimisation information
(typically as defined by the C standard, this is due to Clang performing most optimisations via LLVM
in SSA form). This information is then used by CAPA in the callback in order to determine whether
the region matches satisfies the requirements of the apparent pattern.

\subsubsection{Invoking CAPA}
CAPA is called just like any other Clang tooling plugin, CAPA uses the command line options parser
provided by Clang in order to ensure that information relating to compilation is successfully passed
onto the compiler, whilst parameters necessary within CAPA for analysis are correctly forwarded to
CAPA. There are two main methods of invoking CAPA, the primary and simplest method is calling CAPA
on a single file where the entire compile command for that file is known, in this case calling capa
is as simple as:

\lstinline{CAPA ./codeUnderTest -- clang [compile flags here]}

This however can be augmented through the use of the compile commands database provided by many
build tools, this file contains all the necessary information required for Clang to compile your
project. Invoking CAPA using the compile commands database is as simple as:

\lstinline{CAPA -p ./Location/To/Compile/Commands/Database/ ./codeUnderTest }

With this information, CAPA will be able to successfully pass the required arguments to Clang,
ensuring that the code is compiled correctly, and by extension that CAPA is capable of running
analysis over the generated AST.

\subsubsection{Clang Frontend Action}
The process of calling CAPA results in CAPA initiating the Clang Frontend Action, this is the
component of the Clang compiler that is responsible for generating LLVM Intermediate Representation
from a source file. The Clang Frontend Action lexes and parses the source file, generating the AST
which is then used in the Static Analysis and Code Generation phases before LLVM IR is emitted for
compilation by the LLVM bytecode compiler. CAPA does not require any LLVM IR in order to analyse a
codebase, rather it stops the Clang compilation process after the generation of the AST and provides
requests to Clang through the AST Matcher interface.

\subsubsection{General Note}
In order to integrate fully with Clang, CAPA requires that Clang and llvm be built from source, and
that the Libtooling library interface be explicitly exported as part of the build commands. This is
to ensure that CAPA has the correct Application Binary Interface (ABI) into Clang, without which
CAPA would be unable to perform analysis via the provided AST.



%------------------------------------------------


